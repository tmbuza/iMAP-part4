# (PART) BETA DIVERSITY {-}

# Beta Diversity Dataset {#beta-diversity}

## Data preparation {#prep-beta-data}

### Raw count table
```{r}
library(vegan)
library(zCompositions)
library(tidyverse)

shared <- read_tsv("~/Dropbox/CDILLC/GIT_REPOS/smda-end2end/data/final.tx.shared", show_col_types = F) %>%
  dplyr::select(sample_id = Group, starts_with("Phylo")) %>% 
  pivot_longer(-sample_id) %>%
  group_by(sample_id) %>%
  mutate(total = sum(value)) %>%
  filter(total > 0) %>%
  group_by(name) %>%
  mutate(total = sum(value)) %>%
  filter(total != 0) %>%
  ungroup() %>%
  dplyr::select(-total)

shared
```

### Random count table
```{r}
rand <- shared %>%
  uncount(value) %>%
  mutate(rand_name = sample(name)) %>%
  dplyr::select(-name) %>%
  count(sample_id, rand_name)

rand
```

### Group count summary in ascending
> The table is arranged in ascending order. We need to know the minimum number of sequences for better decisions in sampling depth for statistical analyses.

```{r}
group_count <- rand %>%
  group_by(sample_id) %>%
  summarise(n_seqs = sum(n)) %>% 
  arrange(n_seqs)

group_count
```


### Count range
```{r}
group_count$n_seqs %>% range
```

### Count table matrix
```{r}
shared_matrix <- shared %>%
  pivot_wider(names_from=name, values_from=value, values_fill = 0) %>%
  tibble::column_to_rownames("sample_id")

rand_matrix <- rand %>%
  pivot_wider(names_from=rand_name, values_from=n, values_fill = 0) %>%
  tibble::column_to_rownames("sample_id")

```

# Distance matrices

## Mothur computed distance matrix {#mothur-distance}
```{r}
library(tidyverse, suppressPackageStartupMessages())
source("R/read_matrix.R")

dist_matrix <- read_matrix("../iMAP-part2/data/mothurdata/final.tx.1.subsample.braycurtis.1.lt.dist")

dist_tbl <- tibble::as_tibble(dist_matrix, rownames="sample_id")

sample_lookup <- dist_tbl %>% 
  dplyr::select(sample_id)

mo_dist_matrix <- dist_tbl %>%
  pivot_longer(cols=-sample_id, names_to="b", values_to="distances") %>%
  inner_join(., sample_lookup, by="sample_id") %>%
  inner_join(., sample_lookup, by=c("b" = "sample_id")) %>%
  dplyr::select(sample_id, b, distances) %>%
  pivot_wider(names_from="b", values_from="distances") %>%
  dplyr::select(-sample_id) %>%
  as.dist()


```

## Nonrarefied distance matrix
```{r}
norarefy_eucl_dist <- vegdist(shared_matrix, method="euclidean")
norarefy_bray_dist <- vegdist(shared_matrix, method="bray")
```

## Rarefied distance matrix
> A rarefied sample is computed from the minimum group depth.

```{r}
rarefy_eucl_dist <- vegdist(rand_matrix, method="euclidean", sample = min(group_count$n_seqs))
rarefy_bray_dist <- vegdist(rand_matrix, method="bray", sample = min(group_count$n_seqs))
```

## Aitchson distance matrix
```{r}
gm <- function(x){
  exp(mean(log(x[x>0])))}

rclr_matrix <- rand %>%
  group_by(sample_id) %>%
  mutate(rclr = log(n/gm(n))) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  pivot_wider(names_from=rand_name, values_from=rclr, values_fill=0) %>%
  tibble::column_to_rownames("sample_id")

rclr_eucl_dist <- vegdist(rclr_matrix, method="euclidean")
```


## Count Zero Multiplicative (CZM) distance
```{r message=FALSE, warning=FALSE, paged.print=TRUE}
zclr_matrix <- cmultRepl(rand_matrix, method="CZM", output="p-count") %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(-sample_id) %>%
  group_by(sample_id) %>%
  mutate(zclr = log(value/gm(value))) %>%
  ungroup() %>%
  dplyr::select(-value) %>%
  pivot_wider(names_from=name, values_from=zclr, values_fill=0) %>%
  column_to_rownames("sample_id")

zclr_eucl_dist  <- vegdist(zclr_matrix, method="euclidean")
```


## Arc sine (asin) transformation
```{r}
abund <- readRDS("../iMAP-part3/RDataRDS/composite.rds") %>% 
  dplyr::select(sample_id, otu, rel_abund) %>%
  pivot_wider(id_cols = sample_id, names_from = otu, values_from = rel_abund) %>% 
  tibble::column_to_rownames("sample_id")
x <- abund
y <- x/max(x)
asin_matrix <- round(asin(y), 6)
asin_matrix <- as.matrix(asin_matrix)

asin_eucl_dist  <- vegdist(asin_matrix, method="euclidean")
```


## Creating distance longer dataframes
```{r}
norare_dtbl <- norarefy_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols= -sample_id) %>%
  filter(name < sample_id) %>% 
  rename(norarefy = value)

rare_dtbl <- rarefy_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols= -sample_id) %>%
  filter(name < sample_id) %>% 
  rename(rarefy = value)

rclr_dtbl <- rclr_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(rclr = value)

zclr_dtbl <- zclr_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(zclr = value)

asin_dtbl <- asin_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(asin = value)
```

## Compare distances graphically
```{r}
inner_join(norare_dtbl, rare_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., rclr_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., zclr_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., asin_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., group_count, by=c("sample_id" = "sample_id")) %>%
  inner_join(., group_count, by=c("name" = "sample_id")) %>%
  mutate(diffs = abs(n_seqs.x - n_seqs.y)) %>%
  dplyr::select(sample_id, name, norarefy, rarefy,
                rclr, zclr, asin,diffs) %>%
  pivot_longer(cols=c(norarefy, rarefy, rclr, zclr, asin), names_to="method",
               values_to="dist") %>%
  ggplot(aes(x=diffs, y=dist)) +
  geom_point() +
  facet_wrap(~method, nrow=5, scales="free_y") +
  geom_smooth()
```

## Distances using phyloseq-transformed data
```{r}
library(phyloseq)
library(vegan)
library(tidyverse)
load("../iMAP-part3/RDataRDS/transformed_data_.RData", verbose = T  )

## Compute distances using vegdist function from `vegan` package
ps_asin_eucl_dist  <- vegdist(t(otu_table(ps_asin)), method="euclidean")
ps_identity_eucl_dist  <- vegdist(t(otu_table(ps_identity)), method="euclidean")
ps_compositional_eucl_dist  <- vegdist(t(otu_table(ps_compositional)), method="euclidean")
ps_z_otu_eucl_dist  <- vegdist(t(otu_table(ps_z_otu)), method="euclidean")
ps_z_sample_eucl_dist  <- vegdist(t(otu_table(ps_z_sample)), method="euclidean")
ps_log10_eucl_dist  <- vegdist(t(otu_table(ps_log10)), method="euclidean")
ps_log10p_eucl_dist  <- vegdist(t(otu_table(ps_log10p)), method="euclidean")
ps_clr_eucl_dist  <- vegdist(t(otu_table(ps_clr)), method="euclidean")
ps_shift_eucl_dist  <- vegdist(t(otu_table(ps_shift)), method="euclidean")
ps_scale_eucl_dist  <- vegdist(t(otu_table(ps_scale)), method="euclidean")

## Distance long tables
ps_asin_dtbl <- ps_asin_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_asin = value) %>% 
  dplyr::select(-name)

ps_identity_dtbl <- ps_identity_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_asin = value) %>% 
  dplyr::select(-name)

ps_compositional_dtbl <- ps_compositional_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_compositional = value) %>% 
  dplyr::select(-name)

ps_z_otu_dtbl <- ps_z_otu_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_z_otu = value) %>% 
  dplyr::select(-name)

ps_z_sample_dtbl <- ps_z_sample_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_z_sample = value) %>% 
  dplyr::select(-name)

ps_log10_dtbl <- ps_log10_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_log10 = value) %>% 
  dplyr::select(-name)

ps_log10p_dtbl <- ps_log10p_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_log10p = value) %>% 
  dplyr::select(-name)

ps_clr_dtbl <- ps_clr_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_clr = value) %>% 
  dplyr::select(-name)

ps_shift_dtbl <- ps_shift_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_shift = value) %>% 
  dplyr::select(-name)

ps_scale_dtbl <- ps_scale_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id) %>% 
  rename(ps_scale = value) %>% 
  dplyr::select(-name)
```


# Hierarchical Clustering

```{r}
library(dendextend)
plot(as.dendrogram(hclust(d = norarefy_bray_dist, method = "average")))
```

<!-- # (PART) ORDINATION {-} -->

# Principal Coordinate Analysis (PCoA)
- PCoA is Classical Metric Multidimensional Scaling (MDS)
- All variables are scaled to unit variance before the analysis
- PCoA enables us to plot two axes against each other.
- Axis 1 explains the most variation in the data, axis 2 explains the second most variation, and so forth.


## Using mothur-pcoa.axes
- Import PCoA data and metadata.
- Join metadata and the PCoA data.
- Plot the first two axes.

```{r message=FALSE, warning=FALSE}
source("R/common.R")
library(tidyverse, suppressPackageStartupMessages())

pcoa <- read_tsv(file="../smda-end2end/data/mothurdata/final.tx.1.subsample.braycurtis.1.lt.pcoa.axes", show_col_types = F)
metadata <- read_tsv("../smda-end2end/RDataRDS/mo_metadata.tsv", show_col_types = F) %>%
  filter(isolate == "Buffalo" | isolate == "Wildebeest") %>%
  rename(var1 = isolate)

metadata_pcoa <- inner_join(metadata, pcoa, by=c('sample_id'='group'))

ggplot(metadata_pcoa, aes(x=axis1, y=axis2, color=var1)) +
	geom_point(shape=19, size=3) +
	coord_fixed() +
	labs(title="PCoA of Bray-Curtis Distances",
		x="PCoA Axis 1",
		y="PCoA Axis 2",
		color = "Variable") +
	theme_test()
```


## Using distance matrix directly
- We use the *cmdscale()* function in stats package to compute the axes.

## Computing PCoA axes
```{r}
set.seed(2022)
pcoa <- cmdscale(norarefy_bray_dist, k = (nrow(metadata) - 1), eig = TRUE)
pcoa_variance <- data.frame(PCO = paste("PCO",  seq(1:nrow(as.matrix(norarefy_bray_dist))), sep = ""), 
                           ExplainedVar = round(pcoa$eig^2/sum(pcoa$eig^2), 4))
```

## PCoA scree plot
```{r}
pcoa_variance %>%
  mutate(PCO = factor(pcoa_variance$PCO, 
                      levels = gtools::mixedsort(pcoa_variance$PCO))) %>% 
  ggplot(aes(x = PCO, y = ExplainedVar)) +
  geom_col(fill = "#4682b4") +
  xlab("Principal Coordinate") +
  ylab("Variance Explained") +
  ggtitle("PCoA Scree Plot") +
  ylim(0, 1) +
  theme(axis.text = element_text(size = 10))
```

## PCoA ordination
```{r}
pcoa_1_2_meta <- data.frame(PCO1 = pcoa$points[,1], PCO2 = pcoa$points[,2]) %>% 
  dfRowName("sample_id") %>% 
  inner_join(metadata, pcoa_1_2_meta, by = "sample_id")

perc_expned <- format(round((100 * pcoa$eig / sum(pcoa$eig)), digits =1), nsmall=1, trim=TRUE)

library(glue)
labels <- c(glue("PCo Axis 1 ({perc_expned[1]}%)"),
            glue("PCo Axis 2 ({perc_expned[2]}%)"))

pcoa_1_2_meta %>% 
ggplot(aes(x = PCO1, y = PCO2, color = var1)) +
	geom_point(shape=19, size=3) +
  labs(x=labels[1], y=labels[2], color = "Variable", 
             title = "Principal Component by Variable") +
  theme(legend.position = "right")
```


# NMDS: Non-metric Dimensional Scaling
> NMDS uses a random numebr generator, so set a seed to maintain reproducibility.

```{r include=FALSE}
set.seed(2022)
bray_dist <- as.matrix(readRDS("RDataRDS/bray_dist.rds"))
nmds <- metaMDS(comm = bray_dist, autotransform = T)
```

### NMDS stress plot 2
```{r}
stressplot(nmds)
```

### NMDS ordination
```{r}
nmds$points %>% 
  as_tibble(rownames = "sample_id") %>% 
  inner_join(metadata, ., by=c('sample_id')) %>% 
  ggplot(aes(x = MDS1, y = MDS2, color = var1)) +
	geom_point(shape=19, size=3) +
	labs(title="PCoA of Bray-Curtis Distances",
		x="PCoA Axis 1",
		y="PCoA Axis 2",
		color = "Variable") +
  theme_bw()
```

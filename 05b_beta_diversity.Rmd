# (PART) BETA DIVERSITY {-}

# Beta Diversity Dataset {#beta-diversity}

## Data preparation {#prep-beta-data}

### Raw count table
```{r}
library(vegan)
library(zCompositions)
library(tidyverse)

shared <- read_tsv("~/Dropbox/CDILLC/GIT_REPOS/smda-end2end/data/final.tx.shared", 
                   show_col_types = F) %>%
  dplyr::select(sample_id = Group, starts_with("Phylo")) %>% 
  pivot_longer(-sample_id) %>%
  group_by(sample_id) %>%
  mutate(total = sum(value)) %>%
  filter(total > 1800) %>%
  group_by(name) %>%
  mutate(total = sum(value)) %>%
  filter(total != 0) %>%
  ungroup() %>%
dplyr::select(-total)

shared
```

### Random count table
```{r}
rand <- shared %>%
  uncount(value) %>%
  mutate(rand_name = sample(name)) %>%
dplyr::select(-name) %>%
  count(sample_id, rand_name)

rand
```

### Group count summary in ascending
> The table is arranged in ascending order. We need to know the minimum number of sequences for better decisions in sampling depth for statistical analyses.

```{r}
group_count <- rand %>%
  group_by(sample_id) %>%
  summarize(n_seqs = sum(n)) %>% 
  arrange(n_seqs)

group_count
```


### Count range
```{r}
group_count$n_seqs %>% range
```

### Count table matrix
```{r}
rand_matrix <- rand %>%
  pivot_wider(names_from=rand_name, values_from=n, values_fill = 0) %>%
  tibble::column_to_rownames("sample_id")

rand_matrix[1:5, 1:5]
```

# Computing distance matrices

## All-inclusive distance matrix
```{r}
norarefy_eucl_dist <- vegdist(rand_matrix, method="euclidean")
norarefy_bray_dist <- vegdist(rand_matrix, method="bray")
```

## Rarefied distance matrix
> A rarefied sample is computed from the minimum group depth.

```{r}
rarefy_eucl_dist <- vegdist(rand_matrix, method="euclidean", sample = min(group_count$n_seqs))
rarefy_bray_dist <- vegdist(rand_matrix, method="bray", sample = min(group_count$n_seqs))
```

## Aitchson distance matrix
```{r}
gm <- function(x){
  exp(mean(log(x[x>0])))}

rclr_matrix <- rand %>%
  group_by(sample_id) %>%
  mutate(rclr = log(n/gm(n))) %>%
  ungroup() %>%
  dplyr::select(-n) %>%
  pivot_wider(names_from=rand_name, values_from=rclr, values_fill=0) %>%
  tibble::column_to_rownames("sample_id")

rclr_eucl_dist <- vegdist(rclr_matrix, method="euclidean")
```

## Count Zero Multiplicative (CZM) distance
```{r message=FALSE, warning=FALSE, paged.print=TRUE}
zclr_matrix <- cmultRepl(rand_matrix, method="CZM", output="p-count") %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(-sample_id) %>%
  group_by(sample_id) %>%
  mutate(zclr = log(value/gm(value))) %>%
  ungroup() %>%
dplyr::select(-value) %>%
  pivot_wider(names_from=name, values_from=zclr, values_fill=0) %>%
  column_to_rownames("sample_id")

zclr_eucl_dist  <- vegdist(zclr_matrix, method="euclidean")
```

## Creating distance longer dataframes
```{r}
norare_dtbl <- norarefy_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols= -sample_id) %>%
  filter(name < sample_id)

rare_dtbl <- rarefy_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols= -sample_id) %>%
  filter(name < sample_id)

rclr_dtbl <- rclr_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id)

zclr_dtbl <- zclr_eucl_dist %>%
  as.matrix %>%
  as_tibble(rownames = "sample_id") %>%
  pivot_longer(cols=-sample_id) %>%
  filter(name < sample_id)
```

## Compare distances by point plot
```{r}
inner_join(norare_dtbl, rare_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., rclr_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., zclr_dtbl, by=c("sample_id", "name")) %>%
  inner_join(., group_count, by=c("sample_id" = "sample_id")) %>%
  inner_join(., group_count, by=c("name" = "sample_id")) %>%
  mutate(diffs = abs(n_seqs.x - n_seqs.y)) %>%
  dplyr::select(sample_id, name, norare=value.x, rare=value.y,
                rclr=value.x.x, zclr=value.y.y, diffs) %>%
  pivot_longer(cols=c(norare, rare, rclr, zclr), names_to="method",
               values_to="dist") %>%
  ggplot(aes(x=diffs, y=dist)) +
  geom_point() +
  facet_wrap(~method, nrow=4, scales="free_y") +
  geom_smooth()
```

## Arc sine (asin) transformation
```{r}
abund <- readRDS("../iMAP-part3/RDataRDS/composite.rds") %>% 
  dplyr::select(sample_id, otu, rel_abund) %>%
  pivot_wider(id_cols = sample_id, names_from = otu, values_from = rel_abund) %>% 
  tibble::column_to_rownames("sample_id")
x <- abund
y <- x/max(x)
df_asin <- round(asin(y), 6)
df_asin <- as.matrix(df_asin)
saveRDS(df_asin, "RDataRDS/df_asin.rds")

df_asin[1:5, 1:4]

```


# Hierarchical Clustering

```{r}
library(dendextend)
plot(as.dendrogram(hclust(d = norarefy_bray_dist, method = "average")))
```


# Principal Coordinate Analysis (PCoA)
- PCoA is Classical Metric Multidimensional Scaling (MDS)
- All variables are scaled to unit variance before the analysis
- PCoA enables us to plot two axes against each other.
- Axis 1 explains the most variation in the data, axis 2 explains the second most variation, and so forth.


## Using mothur-pcoa.axes
- Import PCoA data and metadata.
- Join metadata and the PCoA data.
- Plot the first two axes.

```{r message=FALSE, warning=FALSE}
source("R/common.R")
library(tidyverse, suppressPackageStartupMessages())

pcoa <- read_tsv(file="../smda-end2end/data/mothurdata/final.tx.1.subsample.braycurtis.1.lt.pcoa.axes", show_col_types = F)
metadata <- read_tsv("../smda-end2end/RDataRDS/mo_metadata.tsv", show_col_types = F) %>%
  filter(isolate == "Buffalo" | isolate == "Wildebeest") %>%
  rename(var1 = isolate)

metadata_pcoa <- inner_join(metadata, pcoa, by=c('sample_id'='group'))

ggplot(metadata_pcoa, aes(x=axis1, y=axis2, color=var1)) +
	geom_point(shape=19, size=3) +
	coord_fixed() +
	labs(title="PCoA of Bray-Curtis Distances",
		x="PCoA Axis 1",
		y="PCoA Axis 2",
		color = "Variable") +
	theme_test()
```


## Using distance matrix directly
- We use the *cmdscale()* function in stats package to compute the axes.
```{r}
set.seed(2022)
pcoa <- cmdscale(norarefy_bray_dist, k = (nrow(metadata) - 1), eig = TRUE)
pcoa_variance <- data.frame(PCO = paste("PCO",  seq(1:nrow(as.matrix(norarefy_bray_dist))), sep = ""), 
                           ExplainedVar = round(pcoa$eig^2/sum(pcoa$eig^2), 4))

pcoa_variance %>%
  mutate(PCO = factor(pcoa_variance$PCO, levels = gtools::mixedsort(pcoa_variance$PCO))) %>% 
  ggplot(aes(x = PCO, y = ExplainedVar)) +
  geom_col(fill = "#4682b4") +
  xlab("Principal Coordinate") +
  ylab("Variance Explained") +
  ggtitle("PCoA Scree Plot") +
  ylim(0, 1) +
  theme(axis.text = element_text(size = 10))

pcoa_1_2_meta <- data.frame(PCO1 = pcoa$points[,1], PCO2 = pcoa$points[,2]) %>% 
  dfRowName("sample_id") %>% 
  inner_join(metadata, pcoa_1_2_meta, by = "sample_id")

perc_expned <- format(round((100 * pcoa$eig / sum(pcoa$eig)), digits =1), nsmall=1, trim=TRUE)

library(glue)
labels <- c(glue("PCo Axis 1 ({perc_expned[1]}%)"),
            glue("PCo Axis 2 ({perc_expned[2]}%)"))

pcoa_1_2_meta %>% 
ggplot(aes(x = PCO1, y = PCO2, color = var1)) +
  geom_point() +
  geom_point(size = 3) +
  labs(x=labels[1], y=labels[2], color = "Variable", 
             title = "Principal Component by Variable") +
  theme(legend.position = "right")
```


# NMDS Ordination

